{"version":3,"names":["hiddenFormInputSlotName","isCheckable","component","onFormResetMap","WeakMap","formComponentSet","WeakSet","hasRegisteredFormComponentParent","form","formComponentEl","hasParentComponentWithFormIdSet","closestElementCrossShadowBoundary","parentElement","formComponentRegisterEventName","addEventListener","event","composedPath","some","element","has","stopPropagation","once","dispatchEvent","CustomEvent","bubbles","composed","submitForm","formEl","requestSubmit","resetForm","reset","connectForm","el","value","associatedForm","findAssociatedForm","defaultValue","defaultChecked","checked","boundOnFormReset","onFormReset","bind","set","add","queryElementRoots","id","this","disconnectForm","get","removeEventListener","delete","afterConnectDefaultValueSet","hiddenInputChangeHandler","target","removeHiddenInputChangeEventListener","input","syncHiddenFormInput","name","ownerDocument","inputs","querySelectorAll","forEach","remove","values","Array","isArray","extra","seen","Set","valueMatch","find","val","defaultSyncHiddenFormInput","push","docFrag","pop","createElement","slot","createDocumentFragment","append","disabled","required","tabIndex","setAttribute","removeAttribute","HiddenFormInputSlot","h"],"sources":["src/utils/form.tsx"],"sourcesContent":["import { closestElementCrossShadowBoundary, queryElementRoots } from \"./dom\";\nimport { FunctionalComponent, h } from \"@stencil/core\";\n\n/**\n * Exported for testing purposes.\n */\nexport const hiddenFormInputSlotName = \"hidden-form-input\";\n\n/**\n * Defines interface for form owning components.\n *\n * Allows calling submit/reset methods on the form.\n */\nexport interface FormOwner {\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n\n  /**\n   * The ID of the form to associate with the component.\n   *\n   * When not set, the component will be associated with its ancestor form element, if any.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  form: string;\n\n  /**\n   * The form this component is associated with.\n   *\n   * @internal\n   */\n  formEl: HTMLFormElement;\n}\n\n/**\n * Defines interface for form-associated components.\n *\n * Along with the interface, use the matching form utils to help set up the component behavior.\n */\nexport interface FormComponent<T = any> extends FormOwner {\n  /**\n   * When true, this component's value will not be submitted in the form.\n   */\n  disabled: boolean;\n\n  /**\n   * When true, form submit requests will enforce field requirement.\n   *\n   * @todo remove optional in follow-up PR\n   */\n  required?: boolean;\n\n  /**\n   * The name used to submit the value to the associated form.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  name: string;\n\n  /**\n   * This form component's value.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  value: T;\n\n  /**\n   * The initial value for this form component.\n   *\n   * When the form is reset, the value will be set to this property.\n   */\n  defaultValue: T;\n\n  /**\n   * Hook for components to provide custom form reset behavior.\n   */\n  onFormReset?(): void;\n\n  /**\n   * Hook for components to sync _extra_ props on the hidden input form element used for form-submitting.\n   *\n   * Note: The following props are set by default: disabled, hidden, name, required, value.\n   */\n  syncHiddenFormInput?(input: HTMLInputElement): void;\n}\n\n/**\n * Defines interface for checkable form-associated components.\n *\n * Along with the interface, use the matching form utils to help set up the component behavior.\n */\nexport interface CheckableFormComponent<T = any> extends FormComponent<T> {\n  /**\n   * For boolean-valued components, this property defines whether the associated value is submitted to the form or not.\n   */\n  checked: boolean;\n\n  /**\n   * The initial checked value for this form component.\n   *\n   * When the form is reset, the checked property will be set to this value.\n   */\n  defaultChecked: boolean;\n}\n\nfunction isCheckable(component: FormComponent): component is CheckableFormComponent {\n  return \"checked\" in component;\n}\n\nconst onFormResetMap = new WeakMap<HTMLElement, FormComponent[\"onFormReset\"]>();\nconst formComponentSet = new WeakSet<HTMLElement>();\n\n/**\n * This helps determine if our form component is part of a composite form-associated component.\n *\n * @param form\n * @param formComponentEl\n */\nfunction hasRegisteredFormComponentParent(\n  form: HTMLFormElement,\n  formComponentEl: HTMLElement\n): boolean {\n  // if we have a parent component using the form ID attribute, we assume it is form-associated\n  const hasParentComponentWithFormIdSet = closestElementCrossShadowBoundary(\n    formComponentEl.parentElement,\n    \"[form]\"\n  );\n\n  if (hasParentComponentWithFormIdSet) {\n    return true;\n  }\n\n  // we use events as a way to test for nested form-associated components across shadow bounds\n  const formComponentRegisterEventName = \"calciteInternalFormComponentRegister\";\n\n  let hasRegisteredFormComponentParent = false;\n\n  form.addEventListener(\n    formComponentRegisterEventName,\n    (event) => {\n      hasRegisteredFormComponentParent = event\n        .composedPath()\n        .some((element) => formComponentSet.has(element as HTMLElement));\n      event.stopPropagation();\n    },\n    { once: true }\n  );\n\n  formComponentEl.dispatchEvent(\n    new CustomEvent(formComponentRegisterEventName, {\n      bubbles: true,\n      composed: true,\n    })\n  );\n\n  return hasRegisteredFormComponentParent;\n}\n\n/**\n * Helper to submit a form.\n *\n * @param component\n * @returns true if its associated form was submitted, false otherwise.\n */\nexport function submitForm(component: FormOwner): boolean {\n  const { formEl } = component;\n\n  if (!formEl) {\n    return false;\n  }\n\n  formEl.requestSubmit();\n\n  return true;\n}\n\n/**\n * Helper to reset a form.\n *\n * @param component\n */\nexport function resetForm(component: FormOwner): void {\n  component.formEl?.reset();\n}\n\n/**\n * Helper to set up form interactions on connectedCallback.\n *\n * @param component\n */\nexport function connectForm<T>(component: FormComponent<T>): void {\n  const { el, value } = component;\n  const associatedForm = findAssociatedForm(component);\n\n  if (!associatedForm || hasRegisteredFormComponentParent(associatedForm, el)) {\n    return;\n  }\n\n  component.formEl = associatedForm;\n  component.defaultValue = value;\n\n  if (isCheckable(component)) {\n    component.defaultChecked = component.checked;\n  }\n\n  const boundOnFormReset = (component.onFormReset || onFormReset).bind(component);\n  associatedForm.addEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.set(component.el, boundOnFormReset);\n  formComponentSet.add(el);\n}\n\n/**\n * Utility method to find a form-component's associated form element.\n *\n * @param component\n */\nexport function findAssociatedForm(component: FormOwner): HTMLFormElement | null {\n  const { el, form } = component;\n\n  return form\n    ? queryElementRoots<HTMLFormElement>(el, { id: form })\n    : closestElementCrossShadowBoundary<HTMLFormElement>(el, \"form\");\n}\n\nfunction onFormReset<T>(this: FormComponent<T>): void {\n  if (isCheckable(this)) {\n    this.checked = this.defaultChecked;\n    return;\n  }\n\n  this.value = this.defaultValue;\n}\n\n/**\n * Helper to tear down form interactions on disconnectedCallback.\n *\n * @param component\n */\nexport function disconnectForm<T>(component: FormComponent<T>): void {\n  const { el, formEl } = component;\n\n  if (!formEl) {\n    return;\n  }\n\n  const boundOnFormReset = onFormResetMap.get(el);\n  formEl.removeEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.delete(el);\n  component.formEl = null;\n  formComponentSet.delete(el);\n}\n\n/**\n * Helper for setting the default value on initialization after connectedCallback.\n *\n * Note that this is only needed if the default value cannot be determined on connectedCallback.\n *\n * @param component\n * @param value\n */\nexport function afterConnectDefaultValueSet<T>(component: FormComponent<T>, value: any): void {\n  component.defaultValue = value;\n}\n\nconst hiddenInputChangeHandler = (event: Event) => {\n  event.target.dispatchEvent(\n    new CustomEvent(\"calciteInternalHiddenInputChange\", { bubbles: true })\n  );\n};\n\nconst removeHiddenInputChangeEventListener = (input: HTMLInputElement) =>\n  input.removeEventListener(\"change\", hiddenInputChangeHandler);\n\n/**\n * Helper for maintaining a form-associated's hidden input in sync with the component.\n *\n * Based on Ionic's approach: https://github.com/ionic-team/ionic-framework/blob/e4bf052794af9aac07f887013b9250d2a045eba3/core/src/utils/helpers.ts#L198\n *\n * @param component\n */\nfunction syncHiddenFormInput(component: FormComponent): void {\n  const { el, formEl, name, value } = component;\n  const { ownerDocument } = el;\n\n  const inputs = el.querySelectorAll<HTMLInputElement>(`input[slot=\"${hiddenFormInputSlotName}\"]`);\n\n  if (!formEl || !name) {\n    inputs.forEach((input) => {\n      removeHiddenInputChangeEventListener(input);\n      input.remove();\n    });\n    return;\n  }\n\n  const values = Array.isArray(value) ? value : [value];\n  const extra: any[] = [];\n  const seen = new Set<any>();\n\n  inputs.forEach((input) => {\n    const valueMatch = values.find(\n      (val) =>\n        /* intentional non-strict equality check */\n        val == input.value\n    );\n\n    if (valueMatch != null) {\n      seen.add(valueMatch);\n      defaultSyncHiddenFormInput(component, input, valueMatch);\n    } else {\n      extra.push(input);\n    }\n  });\n\n  let docFrag: DocumentFragment;\n\n  values.forEach((value) => {\n    if (seen.has(value)) {\n      return;\n    }\n\n    let input = extra.pop();\n\n    if (!input) {\n      input = ownerDocument!.createElement(\"input\");\n      input.slot = hiddenFormInputSlotName;\n    }\n\n    if (!docFrag) {\n      docFrag = ownerDocument!.createDocumentFragment();\n    }\n\n    docFrag.append(input);\n\n    // emits when hidden input is autofilled\n    input.addEventListener(\"change\", hiddenInputChangeHandler);\n\n    defaultSyncHiddenFormInput(component, input, value);\n  });\n\n  if (docFrag) {\n    el.append(docFrag);\n  }\n  extra.forEach((input) => {\n    removeHiddenInputChangeEventListener(input);\n    input.remove();\n  });\n}\n\nfunction defaultSyncHiddenFormInput(\n  component: FormComponent,\n  input: HTMLInputElement,\n  value: string\n): void {\n  const { defaultValue, disabled, form, name, required } = component;\n\n  // keep in sync to prevent losing reset value\n  input.defaultValue = defaultValue;\n  input.disabled = disabled;\n  input.name = name;\n  input.required = required;\n  input.tabIndex = -1;\n\n  // we set the attr as the prop is read-only\n  if (form) {\n    input.setAttribute(\"form\", form);\n  } else {\n    input.removeAttribute(\"form\");\n  }\n\n  if (isCheckable(component)) {\n    input.checked = component.checked;\n\n    // keep in sync to prevent losing reset value\n    input.defaultChecked = component.defaultChecked;\n    // heuristic to support default/on mode from https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default-on\n    input.value = component.checked ? value || \"on\" : \"\";\n  } else {\n    input.value = value || \"\";\n  }\n\n  component.syncHiddenFormInput?.(input);\n}\n\ninterface HiddenFormInputSlotProps {\n  component: FormComponent;\n}\n\n/**\n * Helper to render the slot for form-associated component's hidden input.\n *\n * If the component has a default slot, this must be placed at the bottom of the component's root container to ensure it is the last child.\n *\n * render(): VNode {\n *   <Host>\n *     <div class={CSS.container}>\n *     // ...\n *     <HiddenFormInputSlot component={this} />\n *     </div>\n *   </Host>\n * }\n *\n * Note that the hidden-form-input Sass mixin must be added to the component's style to apply specific styles.\n *\n * @param root0\n * @param root0.component\n */\nexport const HiddenFormInputSlot: FunctionalComponent<HiddenFormInputSlotProps> = ({\n  component,\n}) => {\n  syncHiddenFormInput(component);\n\n  return <slot name={hiddenFormInputSlotName} />;\n};\n"],"mappings":"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"}